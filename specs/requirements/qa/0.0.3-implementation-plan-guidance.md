# Requirements Q&A Session 0.0.3

**Phase**: 0.0 (Prototype)
**Date Started**: 2026-01-08
**Participants**: Claude, Doctor Headquire
**Purpose**: Define guidance for agents on how to break down design specs into implementation plan steps

---

## Question 1

**Asked by**: Claude
**Question**: What level of granularity should implementation plan steps have? Should each step be a single file operation, a feature component, or something else?

**Answer**: Based on VocabReader pilot project:

**Step = Single logical unit of work**
- Each step accomplishes ONE thing (e.g., "Add CoreData Stack", "Add Settings Entity", "Add iCloud Sync")
- Typically touches 1-3 files maximum
- Results in a compilable, testable state
- **One commit per step** (critical for tracking and rollback)

**Examples of good granularity:**
- "Add CoreData Stack" (creates 2 files, modifies 1 file)
- "Add Settings Entity" (modifies data model, creates manager service)
- "Implement Readium ePub Rendering" (creates 2 views, modifies 1 file)
- "Add Tap Gesture to Extract Word" (modifies 2 existing files)

**Too granular** (avoid):
- "Add import statement to file"
- "Create single property"
- "Write one function"

**Too broad** (avoid):
- "Implement entire translation system" (should be broken into: create service, wire to UI, add error handling, etc.)
- "Build complete library feature" (should be broken into: create views, add storage, implement import, etc.)

---

## Question 2

**Asked by**: Claude
**Question**: What should be included in each step's prompt structure? What details help an agent execute the step correctly?

**Answer**: Based on VocabReader pilot project, use this standardized structure:

**Step Header:**
- Step number and descriptive title (e.g., "Step 1.1: Create Xcode Project")

**File Context:**
- **Files Created:** - List of new files with paths
- **Files Modified:** - List of existing files being changed

**Prompt Block:**
(Blockquote or code fence containing the prompt for the agent)

Main description, then organized by file/component:

**CREATE filename.ext:** or **UPDATE filename.ext:**

**TASKS:**
1. Numbered list of specific actions to take
2. Each task is concrete and actionable
3. Include parameter names, values, and specific details

**REQUIREMENTS:**
- Bulleted list of constraints, rules, or important notes
- Things that MUST or MUST NOT be done
- Technical requirements (e.g., "Use async/await pattern")

**BUILD AND VERIFY:**
Instructions to build and test the implementation

**VERIFICATION CHECKLIST:**
- [ ] Checkbox items for testing the step
- [ ] Each item is a specific thing to verify
- [ ] Should be executable without ambiguity

**After Prompt:**
- **Verification:** Brief summary of what should be verified
- **Status:** Completion status (‚úÖ Complete (date) | ‚è≥ Not Started | üîÑ In Progress)

---

## Question 3

**Asked by**: Claude
**Question**: When should a RESEARCH PHASE section be included in a prompt? I noticed some VocabReader steps had this.

**Answer**: Based on VocabReader pilot project (phase2-interactive-qa-results.md Q6, Feature 3):

Include RESEARCH PHASE when:
1. **There is a significant unknown** that cannot be resolved without investigation
2. **Research must happen in collaboration with the human** before code can be written
3. **The unknown would block implementation** without prior investigation

**Examples from VocabReader:**
- Step 2.1: Study Readium API for ePub rendering (unknown: how Readium's APIs work)
- Step 3.3: Study Readium API for text extraction (unknown: how to get text at tap coordinates)
- Step 3.6: Study Readium Decoration API (unknown: how highlighting works)
- Step 7.0: Kaikki.org research spike (unknown: data structure, SQLite schema design)

**RESEARCH PHASE structure:**
1. List what needs to be investigated
2. Provide starting points (URLs, docs, example code)
3. Specify what to look for or understand
4. Often includes creating a research deliverable document (e.g., `/docs/artifacts/research/kaikki-wiktionary-investigation.md`)

**Important:** Research phases are for unknowns that require **investigation and collaboration**, not for looking up simple API documentation.

---

## Question 4

**Asked by**: Claude
**Question**: How should implementation plans be organized when there are many steps? VocabReader Phase 2 split into multiple files.

**Answer**: Yes, standardize the multi-file approach. It's working well in VocabReader.

**Organization:**
- When a phase has many features (8+ features or 1000+ lines total), split into multiple files
- Create a directory: `specs/implementation-plan/phase-N-name/`
- Create `index.md` with overview and progress tracking table
- Create numbered feature files: `01-feature-name.md`, `02-feature-name.md`, etc.

**Example (VocabReader Phase 2):**
```
specs/implementation-plan/phase-2-expansion/
‚îú‚îÄ‚îÄ index.md                    # Overview, progress table, quick links
‚îú‚îÄ‚îÄ 01-infrastructure.md        # Feature 1: CoreData Infrastructure
‚îú‚îÄ‚îÄ 02-navigation.md            # Feature 2: Navigation & Tabs
‚îú‚îÄ‚îÄ 03-multi-language.md        # Feature 3: Multi-Language Support
‚îú‚îÄ‚îÄ 04-text-customization.md    # Feature 4: Text Customization
‚îú‚îÄ‚îÄ 05-selection.md             # Feature 5: Selection
‚îú‚îÄ‚îÄ 06-interactive-overlay.md   # Feature 6: InteractiveOverlay Refactor
‚îú‚îÄ‚îÄ 07-dictionary.md            # Feature 7: Dictionary Lookups
‚îú‚îÄ‚îÄ 08-nested-translation.md    # Feature 8: Nested Translation
‚îú‚îÄ‚îÄ 09-lists.md                 # Feature 9: Lists System
‚îú‚îÄ‚îÄ 10-adding-to-lists.md       # Feature 10: Adding Items to Lists
‚îú‚îÄ‚îÄ 11-highlights.md            # Feature 11: Persistent Highlights
‚îú‚îÄ‚îÄ 12-reading-position.md      # Feature 12: Reading Position Persistence
‚îî‚îÄ‚îÄ 13-icloud-sync.md           # Feature 13: iCloud Sync
```

**Index file contents:**
- Phase overview and goals
- Progress tracking table (all steps across all features)
- Quick links to each feature file
- Current status and notes

**Benefits:**
- Easier navigation (find specific features quickly)
- Smaller files (easier to edit and review)
- Clear feature boundaries
- Better git diffs (changes isolated to specific feature files)
- Scales well for large phases

---

## Question 5

**Asked by**: Claude
**Question**: What about organizing steps within features? Should features also be broken into stages like VocabReader Phase 1 had?

**Answer**: Yes, stages are very helpful and natural for organizing steps.

**Use stages to:**
- Group related steps into logical milestones
- Create natural checkpoints for testing
- Make progress visible (completed stages show momentum)
- Provide structure for large features

**Example from VocabReader Phase 1:**
- Stage 1: Foundation (Get Readium Working)
  - Step 1.1: Create Xcode Project
  - Step 1.2: Add Readium Dependency
  - Step 1.3: Add Bundled Test ePub
- Stage 2: Reading (Get ePub Displaying)
  - Step 2.1: Implement Readium ePub Rendering
  - Step 2.2: Test Reading Experience on Device
- Stage 3: Translation (Add Tap-to-Translate)
  - Step 3.1: Create Text Extraction Service
  - Step 3.2: Create Translation Service
  - (etc.)

**When to use stages:**
- When a feature has 4+ steps
- When steps naturally cluster into sub-goals
- When there are logical testing checkpoints
- Always use stages for the first phase/MVP (it needs the most structure)

**When NOT to use stages:**
- Small features with 1-3 steps
- Steps are already clearly independent

---

## Question 6

**Asked by**: Claude
**Question**: How detailed should the TASKS section be? Should it include exact parameter names and values?

**Answer**: Depends on what's needed for the agent to complete the task successfully.

**Be specific when:**
- The detail is critical to implementation (e.g., exact data types: "UUID, required")
- There are specific values that must be used (e.g., "default: 1.0")
- The parameter/property name is part of the design spec
- Ambiguity would lead to wrong implementation choices

**Be general when:**
- The implementation details are obvious from context
- The agent has enough information to make good choices
- Over-specifying would constrain reasonable alternatives

**Examples of appropriate specificity:**

**Good (specific when needed):**
```
1. Add property: fontSize (Double, required, default 1.0)
2. Configure with numberOfTapsRequired = 2
3. Use NLTokenizer with unit: .word
```

**Good (general when appropriate):**
```
1. Add error handling for network failures
2. Update the UI to show loading state
3. Implement function to save settings
```

**Too vague (agent won't know what to do):**
```
1. Add some properties
2. Make it work with gestures
3. Handle errors
```

**Rule of thumb:** Include enough detail that the agent doesn't have to guess critical decisions, but trust the agent to handle implementation details.

---

---

## Question 7

**Asked by**: Doctor Headquire
**Question**: What should agents consider about the order and dependencies of stages and steps?

**Answer**: The order is critical. Each step must be individually verifiable and avoid rework.

**Ordering principles:**
1. **Each step must be verifiable** - After completing a step, the product should build, run, and/or pass tests
2. **Avoid rework** - Consider dependencies and preload foundational work when needed
3. **Balance foundation vs scope creep** - Build necessary foundations without expanding scope beyond phase goals
4. **Manageable and testable scope** - Don't build more features or complexity than needed for current phase
5. **Review step size** - Before finalizing the plan, review each step and break down any that are too large

**Example of good ordering (VocabReader):**
- ‚úÖ Step 1.1: Create Project (foundational, verifiable: builds)
- ‚úÖ Step 1.2: Add Dependencies (foundational, verifiable: builds with dependencies)
- ‚úÖ Step 1.3: Add Test ePub (needed for next steps, verifiable: file in bundle)
- ‚úÖ Step 2.1: Implement Rendering (verifiable: see ePub on screen)
- NOT: Step 2.1: Implement Rendering and Translation (too large, should be separate)

**Example of avoiding rework:**
- ‚úÖ Build CoreData infrastructure BEFORE building features that need it
- ‚úÖ Create base UI components BEFORE building complex views
- ‚ùå Build features with temporary storage, then migrate to CoreData later (rework)

**When to preload foundation:**
- Infrastructure needed by multiple features (do it once, early)
- Breaking changes that would affect existing features (do upfront)
- Core architecture patterns (establish early, avoid refactoring)

**When NOT to preload:**
- Features not needed for current phase goals
- Optimizations that can wait
- "Nice to have" improvements

---

## Question 8

**Asked by**: Doctor Headquire
**Question**: What should happen at gates between spec stages and before implementation?

**Answer**: Agent must critically review specs for gaps before proceeding through any gate.

**Gate points in GRIPS:**
1. Requirements approval gate ‚Üí Design Q&A
2. Design approval gate ‚Üí Implementation Plan Q&A
3. Implementation Plan approval gate ‚Üí Start Implementation

**Agent responsibilities at each gate:**
1. **Carefully review current spec phase materials**
2. **Critically analyze for gaps:**
   - Are there unclear requirements?
   - Are there unresolved design decisions?
   - Are there missing details needed for next stage?
   - Are there contradictions or inconsistencies?
   - Are there untested assumptions?
3. **Recommend additional refinement if gaps found:**
   - Suggest specific areas needing clarification
   - Propose additional Q&A sessions if needed
   - Identify questions that need answers
4. **Do NOT proceed until both agent and human are satisfied:**
   - Agent gives explicit recommendation: "Ready to proceed" or "Needs refinement"
   - Human gives explicit approval to pass through gate
   - If either has concerns, conduct additional review cycles

**Example gate review:**
```
Agent: "I've reviewed the Design spec and identified these gaps before
proceeding to Implementation Plan:

1. Section 2.3 mentions 'error recovery strategy' but doesn't specify
   which errors to handle or how
2. The data model shows relationships but not cardinality constraints
3. API authentication approach is mentioned but not defined

Recommendation: Additional Q&A session to resolve these before creating
the implementation plan. Would you like me to start a Q&A session?"
```

**Gate review prevents:**
- Starting implementation with unclear requirements
- Building the wrong thing due to design ambiguity
- Rework from discovering gaps mid-implementation
- Wasted time on implementation that doesn't match intent

---

## Current Understanding

Based on this Q&A session, here are the key principles for breaking down specs into implementation plan steps:

**Granularity:**
- One step = one logical unit of work (typically 1-3 files)
- Results in compilable, testable state
- One commit per step

**Structure:**
- Use stages to group related steps (especially for first phase/MVP)
- Split large phases into multiple files (8+ features or 1000+ lines)
- Use index.md with progress tracking

**Step Format:**
- Files Created / Files Modified
- Prompt block with TASKS, REQUIREMENTS, BUILD AND VERIFY, VERIFICATION CHECKLIST
- Research phases for significant unknowns requiring collaboration
- Verification summary and status

**Level of Detail:**
- Be specific where it matters (data types, exact values, critical decisions)
- Be general where the agent can make good choices
- Include enough detail to avoid guessing on critical decisions

**Ordering and Dependencies:**
- Each step must be individually verifiable (builds/runs/tests)
- Avoid rework by preloading foundational work when needed
- Balance foundation vs scope creep (don't over-build)
- Keep scope manageable and testable per phase
- Review each step and break down steps that are too large

**Gate Reviews:**
- Agent critically reviews specs at each gate for gaps
- Recommend additional refinement before proceeding if needed
- Both agent and human must explicitly approve before passing gates
- Prevents rework from unclear or incomplete specs

---

**Last Updated**: 2026-01-08 (Questions 7-8 + Updated Current Understanding)
